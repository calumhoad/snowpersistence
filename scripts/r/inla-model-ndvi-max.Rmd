---
title: "NDVI.max ~ snow.auc INLA"
author: "Jakob J. Assmann, Calum Hoad"
date: "2024-04-11"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, echo = TRUE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Dependencies
library(tidyverse)
library(sp)
library(gstat)
library(spdep)
library(spatialreg)
library(ggplot2)
library(cowplot)
library(colorspace)
library(pbapply)
library(broom)
library(kableExtra)
library(INLA)

# Opttional set to short inal summary
#inla.setOption(short.summary = TRUE)
```

## Load all data

Load Sentinel-2 data for each site (BL, KL, KH) and HLS S30 data for BL
only.

```{r data, echo = TRUE, message = FALSE, warning = FALSE}
# Load data
s2.bl <- read_csv('../../data/combined-ndvi-snow/s2-bl-smooth-joined.csv',
                  show_col_types = FALSE) %>%
  st_as_sf(coords = c('X', 'Y'), remove = F, crs = 32621) %>%
  group_by(id) %>%
  filter(row_number() == 7) %>%
  ungroup()

# Kluane low
s2.kl <- read_csv('../../data/combined-ndvi-snow/s2-kl-smooth-joined.csv',
                  show_col_types = FALSE) %>%
  st_as_sf(coords = c('X', 'Y'), remove = F, crs = 32608) %>%
  group_by(id) %>%
  filter(row_number() == 7) %>%
  ungroup()

# Kluane high
s2.kh <- read_csv('../../data/combined-ndvi-snow/s2-kh-smooth-joined.csv',
                  show_col_types = FALSE) %>%
  st_as_sf(coords = c('X', 'Y'), remove = F, crs = 32608) %>%
  group_by(id) %>%
  filter(row_number() == 7) %>%
  ungroup()

# Blaesedalen, S30
s30.bl <- read_csv('../../data/combined-ndvi-snow/s30-bl-smooth-joined.csv',
                   show_col_types = FALSE) %>%
  st_as_sf(coords = c('X', 'Y'), remove = F, crs = 32621) %>%
  group_by(id) %>%
  filter(row_number() == 7) %>%
  ungroup()

```

# Blaesedalen, Sentinel-2

## Prepare "node" vector for INLA matern2d model

INLA nodes are arranged as sequential numbers where numbers ascend
column-wise from the top-left corner of the grid towards the
bottom-right. See Fig 7.1 in this document:
<https://becarioprecario.bitbucket.io/inla-gitbook/ch-spatial.html>

In our case, we can derive the column and row numbers from the UTM
coordinates as follows:

col_number = (x - min(x)) / 10 <br> row_number = (max(y) - y) / 10

We can then assign a regularly increasing index (1:n), by infilling the
cells no accounted for.

```{r fig.height = 7, fig.width = 7}
# Calculate row and col_numbers
input.data <- s2.bl %>% 
  # Calculate min X and max >
  mutate(min_x = min(.$X),
         max_y = max(.$Y)) %>%
  # Calczulate colum and row numbers for each cell (top-left to bottom-right corner)
  # We shift by one a R is 1- based
  mutate(col_number = 1 + ((X - min_x) / 10),
         row_number = 1 + ((max_y - Y) / 10)) %>%
  # Arrange dataset accordingly
  arrange(col_number, row_number)

# Derrive spatial index in INLA fashion (running number)
# Optain number of cols and rows
n_col = max(input.data$col_number)
n_row = max(input.data$row_number)
# Expand grid and add index
complete_grid <- expand.grid(1:n_col, 1:n_row) %>%
  # Rename columns
  select(col_number = Var1, row_number = Var2) %>%
  # Rearrange same as data frame above (top-left to bottom-right)
  arrange(col_number, row_number) %>%
  # Generate index ("node")
  mutate(node = 1:nrow(.))

# Add node to input.data, skipping those with no data (left_join)
input.data <- input.data %>%
  left_join(complete_grid, by = c("col_number", "row_number"))

# Plot to visualise
complete_grid_plot <- ggplot() +
  geom_text(data = complete_grid, 
            mapping = aes(x = col_number, y = row_number, label = node),
            size = 1) +
  labs(title = "Complete Grid") +
  scale_y_reverse() +
  coord_equal() +
  theme_map()
kl_node_plot <- ggplot() +
  geom_sf(data = st_buffer(st_geometry(input.data), 5, endCapStyle = "SQUARE"),
          fill = NA) +
  geom_sf_text(data = input.data, 
               aes(label = node),
               size = 1) +
  labs(title = "KL data points only") +
  theme_map()

plot_grid(complete_grid_plot,
          kl_node_plot,
          nrow = 2)

```

Now we have a vector ("node") that represents the spatial arrangement of
the pixels in a way that INLA can understand.

## Fitting a simple INLA model

Next, we fit a super simple INLA model, not worrying about priors for
now.

```{r fit_INLA_s2.bl}
# Specify formula
formula_matern <- ndvi.max ~ snow.auc +
                  f(node, 
                    model = "matern2d", 
                    nrow = n_row,
                    ncol = n_col)
# Fit model
model_matern <- inla(formula = formula_matern, 
                     data = input.data,
                     family = "gaussian",
                     control.predictor = list(compute = TRUE),
                     control.compute = list(dic = TRUE, 
                                            waic = TRUE, 
                                            cpo = TRUE, 
                                            return.marginals.predictor = TRUE),
                     keep = TRUE)
# Print summary
summary(model_matern)
```

[Type out summary of model here]

Let's retrieve the fitted values and marginal predictions.

```{r}
# Calculate marginal predictions depending on snow.auc only
input.data$preds <- model_matern$summary.fixed[1,1] + 
                 input.data$snow.auc * model_matern$summary.fixed[2,1]
# Add model fitted values and residuals to data frame
input.data$fitted <- model_matern$summary.linear.predictor$mean
input.data$residuals <- input.data$ndvi.max - model_matern$summary.linear.predictor$mean
```

Produce variograms to better understand the spatial structure of the
data and to assess whether the INLA model with non-informative priors
appropriately accounts for spatial autocorrelation.

```{r warning=FALSE}
# Fit variogram snow
vario_snow <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(snow.auc ~ 1, data = ., cutoff = 130, width = 10)
vario_snow.max_fit <- fit.variogram(vario_snow, model = vgm(model = "Mat")) 


# Visualise results
vario.snow <- ggplot(data = vario_snow) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_snow.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_snow.max_fit$range) +
    annotate("text", x = vario_snow.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_snow.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "snow.auc") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# Fit variogram ndvi max doy
vario_doy <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(ndvi.max ~ 1, data = ., cutoff = 130, width = 10)
vario_doy.max_fit <- fit.variogram(vario_doy, model = vgm(model = "Mat")) 


# Visualise results
vario.doy <- ggplot(data = vario_doy) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_doy.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_doy.max_fit$range) +
    annotate("text", x = vario_doy.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_doy.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "ndvi.max") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

# LM residuals variogram

# Fit variogram linear model
doy.snow.lm <- lm(input.data$ndvi.max ~ input.data$snow.auc)

# Fit variogram residuals
vario_resid_lm <- input.data %>% mutate(lm.resid = doy.snow.lm$residuals) %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(lm.resid ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_lm_fit <- fit.variogram(vario_resid_lm, model = vgm(model = "Mat")) 


# Visualise results
vario.lm <- ggplot(data = vario_resid_lm) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_lm_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_lm_fit$range) +
    annotate("text", x = vario_resid_lm_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_lm_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "LM resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# INLA model residuals variogram
vario_resid_inla <- input.data %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(residuals ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_inla_fit <- fit.variogram(vario_resid_inla, model = vgm(model = "Sph")) 
# Visualise results
vario.inla <- ggplot(data = vario_resid_inla) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_inla_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_inla_fit$range) +
    annotate("text", x = vario_resid_inla_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_inla_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "INLA resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

plot_grid(vario.snow, vario.doy,
          vario.lm, vario.inla,
          align = 'v',
          ncol = 2, 
          nrow = 2)
```

Graph fitted values and marginal predictions.

```{r}
# Graph data, fitted values and predictions
ggplot(data = input.data) +
  geom_point(aes(x = snow.auc, y= ndvi.max),
             colour = 'red') +
  geom_point(aes(x = snow.auc, y = fitted),
             colour = "blue", 
             alpha = 0.5) +
  geom_line(aes(x = snow.auc, preds),
            colour = "blue") +
  theme_cowplot()

```

Let's have a look at how the predictions are distributed in space:

```{r fig.widht = 7, fig.height = 7}
plot_grid(ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = snow.auc)) +
  scale_fill_continuous_sequential("blue") +
  labs(fill = "snow.auc") +
  theme_map(),
  ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = preds)) +
  scale_fill_continuous_sequential("viridis", rev = F) +
  labs(fill = "predictions\nNDVI max") +
  theme_map(),
  nrow = 2)
  
```

The predictions are accurate, but the fit of the line is almost at a
slope of 0. It seems like the model may need to be non-linear, to
account for the larger number of observations between 0-5 snow.auc and
the apparent positive relationship between snow.auc and ndvi.max for
these values.

Next we need to check whether there is still any autocorrelation in the
residuals and whether these follow a Gaussian distribution (as assumed).

## Graph residuals

```{r fig.height = 7, fig.width = 7}
# Graph residuals as histogram and in space
plot_grid(ggplot(input.data) +
  geom_histogram(aes(x = residuals), bins = 50) +
  labs(x = "residuals") +
  theme_cowplot(),
ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), aes(fill = residuals)) +
  scale_fill_continuous_diverging() +
  theme_map(),
nrow = 2)

```

The histogram of the residuals follows a nice normal distribution -
great!

It also seems like the model does an excellent job at accounting for the
spatial autocorrelation. The residual are are seemingly randomly
distributed in space.

As a last check, let's look at the variation accounted for by the latent
spatial effect.

```{r}
ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = ndvi.max - preds - residuals)) +
  scale_fill_continuous_diverging() +
  labs(fill = "spatial effect") +
  theme_map()
```

The latent spatial effect of the model manages to account for a lot of
the residual variation. That makes a lot of ecological sense, as we'd
think that the majority in NDVI variation is not explained by our
predictor.

The way I understand the spatial latent effect is that INLA fits an an
"random error term" to each individual node where the error term is
described by a matern function based on the surrounding neighbourhood of
the node. I am not 100% certain that is really how it works, but will
run this past a colleague to dig deeper.

------------------------------------------------------------------------

# Kluane Low, Sentinel-2

## Prepare "node" vector for INLA matern2d model

```{r fig.height = 7, fig.width = 7}
# Calculate row and col_numbers
input.data <- s2.kl %>% 
  # Calculate min X and max >
  mutate(min_x = min(.$X),
         max_y = max(.$Y)) %>%
  # Calczulate colum and row numbers for each cell (top-left to bottom-right corner)
  # We shift by one a R is 1- based
  mutate(col_number = 1 + ((X - min_x) / 10),
         row_number = 1 + ((max_y - Y) / 10)) %>%
  # Arrange dataset accordingly
  arrange(col_number, row_number)

# Derrive spatial index in INLA fashion (running number)
# Optain number of cols and rows
n_col = max(input.data$col_number)
n_row = max(input.data$row_number)
# Expand grid and add index
complete_grid <- expand.grid(1:n_col, 1:n_row) %>%
  # Rename columns
  select(col_number = Var1, row_number = Var2) %>%
  # Rearrange same as data frame above (top-left to bottom-right)
  arrange(col_number, row_number) %>%
  # Generate index ("node")
  mutate(node = 1:nrow(.))

# Add node to input.data, skipping those with no data (left_join)
input.data <- input.data %>%
  left_join(complete_grid, by = c("col_number", "row_number"))

# Plot to visualise
complete_grid_plot <- ggplot() +
  geom_text(data = complete_grid, 
            mapping = aes(x = col_number, y = row_number, label = node),
            size = 1) +
  labs(title = "Complete Grid") +
  scale_y_reverse() +
  coord_equal() +
  theme_map()
kl_node_plot <- ggplot() +
  geom_sf(data = st_buffer(st_geometry(input.data), 5, endCapStyle = "SQUARE"),
          fill = NA) +
  geom_sf_text(data = input.data, 
               aes(label = node),
               size = 1) +
  labs(title = "KL data points only") +
  theme_map()

plot_grid(complete_grid_plot,
          kl_node_plot,
          nrow = 2)

```

## Fitting a simple INLA model

```{r fit_INLA_s2.kl}
# Specify formula
formula_matern <- ndvi.max ~ snow.auc +
                  f(node, 
                    model = "matern2d", 
                    nrow = n_row,
                    ncol = n_col)
# Fit model
model_matern <- inla(formula = formula_matern, 
                     data = input.data,
                     family = "gaussian",
                     control.predictor = list(compute = TRUE),
                     control.compute = list(dic = TRUE, 
                                            waic = TRUE, 
                                            cpo = TRUE, 
                                            return.marginals.predictor = TRUE),
                     keep = TRUE)
# Print summary
summary(model_matern)
```

[Type out summary of model here]

Let's retrieve the fitted values and marginal predictions.

```{r}
# Calculate marginal predictions depending on snow.auc only
input.data$preds <- model_matern$summary.fixed[1,1] + 
                 input.data$snow.auc * model_matern$summary.fixed[2,1]
# Add model fitted values and residuals to data frame
input.data$fitted <- model_matern$summary.linear.predictor$mean
input.data$residuals <- input.data$ndvi.max - model_matern$summary.linear.predictor$mean
```

Produce variograms to better understand the spatial structure of the
data and to assess whether the INLA model with non-informative priors
appropriately accounts for spatial autocorrelation.

```{r warning=FALSE}
# Fit variogram snow
vario_snow <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(snow.auc ~ 1, data = ., cutoff = 130, width = 10)
vario_snow.max_fit <- fit.variogram(vario_snow, model = vgm(model = "Mat")) 


# Visualise results
vario.snow <- ggplot(data = vario_snow) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_snow.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_snow.max_fit$range) +
    annotate("text", x = vario_snow.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_snow.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "snow.auc") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# Fit variogram ndvi max doy
vario_doy <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(ndvi.max ~ 1, data = ., cutoff = 130, width = 10)
vario_doy.max_fit <- fit.variogram(vario_doy, model = vgm(model = "Mat")) 


# Visualise results
vario.doy <- ggplot(data = vario_doy) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_doy.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_doy.max_fit$range) +
    annotate("text", x = vario_doy.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_doy.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "ndvi.max") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

# LM residuals variogram

# Fit variogram linear model
doy.snow.lm <- lm(input.data$ndvi.max ~ input.data$snow.auc)

# Fit variogram residuals
vario_resid_lm <- input.data %>% mutate(lm.resid = doy.snow.lm$residuals) %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(lm.resid ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_lm_fit <- fit.variogram(vario_resid_lm, model = vgm(model = "Mat")) 


# Visualise results
vario.lm <- ggplot(data = vario_resid_lm) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_lm_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_lm_fit$range) +
    annotate("text", x = vario_resid_lm_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_lm_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "LM resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# INLA model residuals variogram
vario_resid_inla <- input.data %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(residuals ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_inla_fit <- fit.variogram(vario_resid_inla, model = vgm(model = "Sph")) 
# Visualise results
vario.inla <- ggplot(data = vario_resid_inla) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_inla_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_inla_fit$range) +
    annotate("text", x = vario_resid_inla_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_inla_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "INLA resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

plot_grid(vario.snow, vario.doy,
          vario.lm, vario.inla,
          align = 'v',
          ncol = 2, 
          nrow = 2)
```

Graph fitted values and marginal predictions.

```{r}
# Graph data, fitted values and predictions
ggplot(data = input.data) +
  geom_point(aes(x = snow.auc, y= ndvi.max),
             colour = 'red') +
  geom_point(aes(x = snow.auc, y = fitted),
             colour = "blue", 
             alpha = 0.5) +
  geom_line(aes(x = snow.auc, preds),
            colour = "blue") +
  theme_cowplot()

```

The fitted values (blue) are very close to the observed values (red).
Suggesting that the model (including the spatial random effect) does
manage to account for a lot of the variation in the data (very good!).
The fitted slope and intercept seem both reasonable given the observed
data.

Let's have a look at how the predictions are distributed in space:

```{r fig.widht = 7, fig.height = 7}
plot_grid(ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = snow.auc)) +
  scale_fill_continuous_sequential("blue") +
  labs(fill = "snow.auc") +
  theme_map(),
  ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = preds)) +
  scale_fill_continuous_sequential("viridis", rev = F) +
  labs(fill = "predictions\nNDVI max") +
  theme_map(),
  nrow = 2)
  
```

This looks great and seems to make sense given the hypothesised
relationship.

Next we need to check whether there is still any autocorrelation in the
residuals and whether these follow a Gaussian distribution (as assumed).

## Graph residuals

```{r fig.height = 7, fig.width = 7}
# Graph residuals as histogram and in space
plot_grid(ggplot(input.data) +
  geom_histogram(aes(x = residuals), bins = 50) +
  labs(x = "residuals") +
  theme_cowplot(),
ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), aes(fill = residuals)) +
  scale_fill_continuous_diverging() +
  theme_map(),
nrow = 2)

```

The histogram of the residuals follows a nice normal distribution -
great!

It also seems like the model does an excellent job at accounting for the
spatial autocorrelation. The residual are are seemingly randomly
distributed in space.

As a last check, let's look at the variation accounted for by the latent
spatial effect.

```{r}
ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = ndvi.max - preds - residuals)) +
  scale_fill_continuous_diverging() +
  labs(fill = "spatial effect") +
  theme_map()
```

The latent spatial effect of the model manages to account for a lot of
the residual variation. That makes a lot of ecological sense, as we'd
think that the majority in NDVI variation is not explained by our
predictor.

------------------------------------------------------------------------

# Kluane High, Sentinel-2

## Prepare "node" vector for INLA matern2d model

```{r fig.height = 7, fig.width = 7}
# Calculate row and col_numbers
input.data <- s2.kh %>% 
  # Calculate min X and max >
  mutate(min_x = min(.$X),
         max_y = max(.$Y)) %>%
  # Calczulate colum and row numbers for each cell (top-left to bottom-right corner)
  # We shift by one a R is 1- based
  mutate(col_number = 1 + ((X - min_x) / 10),
         row_number = 1 + ((max_y - Y) / 10)) %>%
  # Arrange dataset accordingly
  arrange(col_number, row_number)

# Derrive spatial index in INLA fashion (running number)
# Optain number of cols and rows
n_col = max(input.data$col_number)
n_row = max(input.data$row_number)
# Expand grid and add index
complete_grid <- expand.grid(1:n_col, 1:n_row) %>%
  # Rename columns
  select(col_number = Var1, row_number = Var2) %>%
  # Rearrange same as data frame above (top-left to bottom-right)
  arrange(col_number, row_number) %>%
  # Generate index ("node")
  mutate(node = 1:nrow(.))

# Add node to input.data, skipping those with no data (left_join)
input.data <- input.data %>%
  left_join(complete_grid, by = c("col_number", "row_number"))

# Plot to visualise
complete_grid_plot <- ggplot() +
  geom_text(data = complete_grid, 
            mapping = aes(x = col_number, y = row_number, label = node),
            size = 1) +
  labs(title = "Complete Grid") +
  scale_y_reverse() +
  coord_equal() +
  theme_map()
kl_node_plot <- ggplot() +
  geom_sf(data = st_buffer(st_geometry(input.data), 5, endCapStyle = "SQUARE"),
          fill = NA) +
  geom_sf_text(data = input.data, 
               aes(label = node),
               size = 1) +
  labs(title = "KL data points only") +
  theme_map()

plot_grid(complete_grid_plot,
          kl_node_plot,
          nrow = 2)

```

## Fitting a simple INLA model

```{r fit_INLA_s2.kh}
# Specify formula
formula_matern <- ndvi.max ~ snow.auc +
                  f(node, 
                    model = "matern2d", 
                    nrow = n_row,
                    ncol = n_col)
# Fit model
model_matern <- inla(formula = formula_matern, 
                     data = input.data,
                     family = "gaussian",
                     control.predictor = list(compute = TRUE),
                     control.compute = list(dic = TRUE, 
                                            waic = TRUE, 
                                            cpo = TRUE, 
                                            return.marginals.predictor = TRUE),
                     keep = TRUE)
# Print summary
summary(model_matern)
```

[Type out summary of model here]

Let's retrieve the fitted values and marginal predictions.

```{r}
# Calculate marginal predictions depending on snow.auc only
input.data$preds <- model_matern$summary.fixed[1,1] + 
                 input.data$snow.auc * model_matern$summary.fixed[2,1]
# Add model fitted values and residuals to data frame
input.data$fitted <- model_matern$summary.linear.predictor$mean
input.data$residuals <- input.data$ndvi.max - model_matern$summary.linear.predictor$mean
```

Produce variograms to better understand the spatial structure of the
data and to assess whether the INLA model with non-informative priors
appropriately accounts for spatial autocorrelation.

```{r warning=FALSE}
# Fit variogram snow
vario_snow <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(snow.auc ~ 1, data = ., cutoff = 130, width = 10)
vario_snow.max_fit <- fit.variogram(vario_snow, model = vgm(model = "Mat")) 


# Visualise results
vario.snow <- ggplot(data = vario_snow) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_snow.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_snow.max_fit$range) +
    annotate("text", x = vario_snow.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_snow.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "snow.auc") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# Fit variogram ndvi max doy
vario_doy <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(ndvi.max ~ 1, data = ., cutoff = 130, width = 10)
vario_doy.max_fit <- fit.variogram(vario_doy, model = vgm(model = "Mat")) 


# Visualise results
vario.doy <- ggplot(data = vario_doy) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_doy.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_doy.max_fit$range) +
    annotate("text", x = vario_doy.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_doy.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "ndvi.max") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

# LM residuals variogram

# Fit variogram linear model
doy.snow.lm <- lm(input.data$ndvi.max ~ input.data$snow.auc)

# Fit variogram residuals
vario_resid_lm <- input.data %>% mutate(lm.resid = doy.snow.lm$residuals) %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(lm.resid ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_lm_fit <- fit.variogram(vario_resid_lm, model = vgm(model = "Mat")) 


# Visualise results
vario.lm <- ggplot(data = vario_resid_lm) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_lm_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_lm_fit$range) +
    annotate("text", x = vario_resid_lm_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_lm_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "LM resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# INLA model residuals variogram
vario_resid_inla <- input.data %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(residuals ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_inla_fit <- fit.variogram(vario_resid_inla, model = vgm(model = "Sph")) 
# Visualise results
vario.inla <- ggplot(data = vario_resid_inla) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_inla_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_inla_fit$range) +
    annotate("text", x = vario_resid_inla_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_inla_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "INLA resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

plot_grid(vario.snow, vario.doy,
          vario.lm, vario.inla,
          align = 'v',
          ncol = 2, 
          nrow = 2)
```

Graph fitted values and marginal predictions.

```{r}
# Graph data, fitted values and predictions
ggplot(data = input.data) +
  geom_point(aes(x = snow.auc, y= ndvi.max),
             colour = 'red') +
  geom_point(aes(x = snow.auc, y = fitted),
             colour = "blue", 
             alpha = 0.5) +
  geom_line(aes(x = snow.auc, preds),
            colour = "blue") +
  theme_cowplot()

```

The fitted values (blue) are very close to the observed values (red).
Suggesting that the model (including the spatial random effect) does
manage to account for a lot of the variation in the data (very good!).
The fitted slope and intercept seem both reasonable given the observed
data.

Let's have a look at how the predictions are distributed in space:

```{r fig.widht = 7, fig.height = 7}
plot_grid(ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = snow.auc)) +
  scale_fill_continuous_sequential("blue") +
  labs(fill = "snow.auc") +
  theme_map(),
  ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = preds)) +
  scale_fill_continuous_sequential("viridis", rev = F) +
  labs(fill = "predictions\nNDVI max") +
  theme_map(),
  nrow = 2)
  
```

This looks great and seems to make sense given the hypothesised
relationship.

Next we need to check whether there is still any autocorrelation in the
residuals and whether these follow a Gaussian distribution (as assumed).

## Graph residuals

```{r fig.height = 7, fig.width = 7}
# Graph residuals as histogram and in space
plot_grid(ggplot(input.data) +
  geom_histogram(aes(x = residuals), bins = 50) +
  labs(x = "residuals") +
  theme_cowplot(),
ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), aes(fill = residuals)) +
  scale_fill_continuous_diverging() +
  theme_map(),
nrow = 2)

```

The histogram of the residuals follows a nice normal distribution -
great!

It also seems like the model does an excellent job at accounting for the
spatial autocorrelation. The residual are are seemingly randomly
distributed in space.

As a last check, let's look at the variation accounted for by the latent
spatial effect.

```{r}
ggplot() +
  geom_sf(data = st_buffer(input.data, 5, endCapStyle = "SQUARE"), 
          aes(fill = ndvi.max - preds - residuals)) +
  scale_fill_continuous_diverging() +
  labs(fill = "spatial effect") +
  theme_map()
```

The latent spatial effect of the model manages to account for a lot of
the residual variation. That makes a lot of ecological sense, as we'd
think that the majority in NDVI variation is not explained by our
predictor.

------------------------------------------------------------------------

# Blaesedalen, HLS S30

## Prepare "node" vector for INLA matern2d model

For NASA HLS S30 data, we can derive the column and row numbers from the
UTM coordinates as follows:

col_number = (x - min(x)) / 30 <br> row_number = (max(y) - y) / 30

We can then assign a regularly increasing index (1:n), by infilling the
cells no accounted for.

```{r fig.height = 7, fig.width = 7}
# Calculate row and col_numbers
input.data <- s30.bl %>% 
  # Calculate min X and max >
  mutate(min_x = min(.$X),
         max_y = max(.$Y)) %>%
  # Calczulate colum and row numbers for each cell (top-left to bottom-right corner)
  # We shift by one a R is 1- based
  mutate(col_number = 1 + ((X - min_x) / 30),
         row_number = 1 + ((max_y - Y) / 30)) %>%
  # Arrange dataset accordingly
  arrange(col_number, row_number)

# Derrive spatial index in INLA fashion (running number)
# Optain number of cols and rows
n_col = max(input.data$col_number)
n_row = max(input.data$row_number)
# Expand grid and add index
complete_grid <- expand.grid(1:n_col, 1:n_row) %>%
  # Rename columns
  select(col_number = Var1, row_number = Var2) %>%
  # Rearrange same as data frame above (top-left to bottom-right)
  arrange(col_number, row_number) %>%
  # Generate index ("node")
  mutate(node = 1:nrow(.))

# Add node to input.data, skipping those with no data (left_join)
input.data <- input.data %>%
  left_join(complete_grid, by = c("col_number", "row_number"))

# Plot to visualise
complete_grid_plot <- ggplot() +
  geom_text(data = complete_grid, 
            mapping = aes(x = col_number, y = row_number, label = node),
            size = 1) +
  labs(title = "Complete Grid") +
  scale_y_reverse() +
  coord_equal() +
  theme_map()
kl_node_plot <- ggplot() +
  geom_sf(data = st_buffer(st_geometry(input.data), 5, endCapStyle = "SQUARE"),
          fill = NA) +
  geom_sf_text(data = input.data, 
               aes(label = node),
               size = 1) +
  labs(title = "KL data points only") +
  theme_map()

plot_grid(complete_grid_plot,
          kl_node_plot,
          nrow = 2)

```

Now we have a vector ("node") that represents the spatial arrangement of
the pixels in a way that INLA can understand.

## Fitting a simple INLA model

Next, we fit a super simple INLA model, not worrying about priors for
now.

```{r fit_INLA_s30.bl}
# Specify formula
formula_matern <- ndvi.max ~ snow.auc +
                  f(node, 
                    model = "matern2d", 
                    nrow = n_row,
                    ncol = n_col)
# Fit model
model_matern <- inla(formula = formula_matern, 
                     data = input.data,
                     family = "gaussian",
                     control.predictor = list(compute = TRUE),
                     control.compute = list(dic = TRUE, 
                                            waic = TRUE, 
                                            cpo = TRUE, 
                                            return.marginals.predictor = TRUE),
                     keep = TRUE)
# Print summary
summary(model_matern)
```

[Type out summary of model here]

Let's retrieve the fitted values and marginal predictions.

```{r}
# Calculate marginal predictions depending on snow.auc only
input.data$preds <- model_matern$summary.fixed[1,1] + 
                 input.data$snow.auc * model_matern$summary.fixed[2,1]
# Add model fitted values and residuals to data frame
input.data$fitted <- model_matern$summary.linear.predictor$mean
input.data$residuals <- input.data$ndvi.max - model_matern$summary.linear.predictor$mean
```

Produce variograms to better understand the spatial structure of the
data and to assess whether the INLA model with non-informative priors
appropriately accounts for spatial autocorrelation.

```{r warning=FALSE}
# Fit variogram snow
vario_snow <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(snow.auc ~ 1, data = ., cutoff = 130, width = 10)
vario_snow.max_fit <- fit.variogram(vario_snow, model = vgm(model = "Mat")) 


# Visualise results
vario.snow <- ggplot(data = vario_snow) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_snow.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_snow.max_fit$range) +
    annotate("text", x = vario_snow.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_snow.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "snow.auc") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# Fit variogram ndvi max doy
vario_doy <- as_Spatial(input.data) %>% as("SpatialPointsDataFrame") %>%
  variogram(ndvi.max ~ 1, data = ., cutoff = 130, width = 10)
vario_doy.max_fit <- fit.variogram(vario_doy, model = vgm(model = "Mat")) 


# Visualise results
vario.doy <- ggplot(data = vario_doy) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_doy.max_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_doy.max_fit$range) +
    annotate("text", x = vario_doy.max_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_doy.max_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "ndvi.max") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

# LM residuals variogram

# Fit variogram linear model
doy.snow.lm <- lm(input.data$ndvi.max ~ input.data$snow.auc)

# Fit variogram residuals
vario_resid_lm <- input.data %>% mutate(lm.resid = doy.snow.lm$residuals) %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(lm.resid ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_lm_fit <- fit.variogram(vario_resid_lm, model = vgm(model = "Mat")) 


# Visualise results
vario.lm <- ggplot(data = vario_resid_lm) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_lm_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_lm_fit$range) +
    annotate("text", x = vario_resid_lm_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_lm_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "LM resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))


# INLA model residuals variogram
vario_resid_inla <- input.data %>%
  as_Spatial() %>% 
  as("SpatialPointsDataFrame") %>%
  variogram(residuals ~ 1, data = ., cutoff = 130, width = 10)
vario_resid_inla_fit <- fit.variogram(vario_resid_inla, model = vgm(model = "Sph")) 
# Visualise results
vario.inla <- ggplot(data = vario_resid_inla) +
    geom_point(aes(x = dist, y = gamma)) +
    geom_line(aes(x = dist, y = gamma), 
              data = variogramLine(vario_resid_inla_fit, 
                                   dist_vector = seq(10,130,10))) +
    geom_vline(xintercept = vario_resid_inla_fit$range) +
    annotate("text", x = vario_resid_inla_fit$range, y  = Inf, 
             label = paste0(" range = ", round(vario_resid_inla_fit$range, 1), " m"),
             hjust = 0, vjust = 1.5, color = 'red') +
    scale_x_continuous(limits = c(10, 130), breaks = seq(10,130,20)) +
    labs(x = "lag distance (m)", y = "INLA resid") +
    theme_cowplot() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))

plot_grid(vario.snow, vario.doy,
          vario.lm, vario.inla,
          align = 'v',
          ncol = 2, 
          nrow = 2)
```

Graph fitted values and marginal predictions.

```{r}
# Graph data, fitted values and predictions
ggplot(data = input.data) +
  geom_point(aes(x = snow.auc, y= ndvi.max),
             colour = 'red') +
  geom_point(aes(x = snow.auc, y = fitted),
             colour = "blue", 
             alpha = 0.5) +
  geom_line(aes(x = snow.auc, preds),
            colour = "blue") +
  theme_cowplot()

```

The fitted values (blue) are very close to the observed values (red).
Suggesting that the model (including the spatial random effect) does
manage to account for a lot of the variation in the data (very good!).
The fitted slope and intercept seem both reasonable given the observed
data.

Let's have a look at how the predictions are distributed in space:

```{r fig.widht = 7, fig.height = 7}
plot_grid(ggplot() +
  geom_sf(data = st_buffer(input.data, 15, endCapStyle = "SQUARE"), 
          aes(fill = snow.auc)) +
  scale_fill_continuous_sequential("blue") +
  labs(fill = "snow.auc") +
  theme_map(),
  ggplot() +
  geom_sf(data = st_buffer(input.data, 15, endCapStyle = "SQUARE"), 
          aes(fill = preds)) +
  scale_fill_continuous_sequential("viridis", rev = F) +
  labs(fill = "predictions\nNDVI max") +
  theme_map(),
  nrow = 2)
  
```

This looks great and seems to make sense given the hypothesised
relationship.

Next we need to check whether there is still any autocorrelation in the
residuals and whether these follow a Gaussian distribution (as assumed).

## Graph residuals

```{r fig.height = 7, fig.width = 7}
# Graph residuals as histogram and in space
plot_grid(ggplot(input.data) +
  geom_histogram(aes(x = residuals), bins = 50) +
  labs(x = "residuals") +
  theme_cowplot(),
ggplot() +
  geom_sf(data = st_buffer(input.data, 15, endCapStyle = "SQUARE"), aes(fill = residuals)) +
  scale_fill_continuous_diverging() +
  theme_map(),
nrow = 2)

```

The histogram of the residuals follows a nice normal distribution -
great!

It also seems like the model does an excellent job at accounting for the
spatial autocorrelation. The residual are are seemingly randomly
distributed in space.

As a last check, let's look at the variation accounted for by the latent
spatial effect.

```{r}
ggplot() +
  geom_sf(data = st_buffer(input.data, 15, endCapStyle = "SQUARE"), 
          aes(fill = ndvi.max - preds - residuals)) +
  scale_fill_continuous_diverging() +
  labs(fill = "spatial effect") +
  theme_map()
```

The latent spatial effect of the model manages to account for a lot of
the residual variation. That makes a lot of ecological sense, as we'd
think that the majority in NDVI variation is not explained by our
predictor.
